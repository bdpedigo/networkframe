{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#networkframe","title":"networkframe","text":"<p>Lightweight representations of networks using Pandas DataFrames.</p> <ul> <li>Documentation: https://bdpedigo.github.io/networkframe</li> <li>GitHub: https://github.com/bdpedigo/networkframe</li> <li>PyPI: https://pypi.org/project/networkframe/</li> <li>Free software: MIT</li> </ul> <p><code>networkframe</code> uses Pandas DataFrames to represent networks in a lightweight way. A <code>NetworkFrame</code> object is simply a table representing nodes and a table representing edges, and a variety of methods to make querying and manipulating that data easy.</p> <p>Pros:</p> <ul> <li>Lightweight: <code>NetworkFrame</code> objects are just two DataFrames, so they're easy to manipulate and integrate with other tools.</li> <li>Interoperable: can output to <code>NetworkX</code>, <code>numpy</code> and <code>scipy</code> sparse matrices, and other formats (coming soon).</li> <li>Flexible: can represent directed, undirected, and multigraphs.</li> <li>Familiar: if you're familiar with <code>Pandas</code> <code>DataFrames</code>, that is. As much as possible, <code>networkframe</code> uses the same syntax as <code>Pandas</code>, but also just gives you access to the underlying tables.</li> <li>Extensible: it's easy to use <code>NetworkFrame</code> as a base graph - for instance, you could make a <code>SpatialNetworkFrame</code> that adds spatial information to the nodes and edges.</li> </ul> <p>Cons:</p> <ul> <li>No guarantees: since <code>networkframe</code> gives you access to the underlying <code>DataFrames</code>, it doesn't do much validation of the data.</li> <li>Not optimized for graph computations: since <code>networkframe</code> is storing data as simple node and edge tables, it's not optimized for doing actual computations on those graphs (e.g. like searching for shortest paths). A typical workflow would be to use <code>networkframe</code> to load and manipulate your data, then convert to a more graph-oriented format like <code>scipy</code> sparse matrices or <code>NetworkX</code> for computations.</li> </ul> <p>Room for improvement:</p> <ul> <li>Early development: there are likely bugs and missing features. Please report any issues you find!</li> <li>More interoperability: <code>networkframe</code> can currently output to <code>NetworkX</code>, <code>numpy</code> and <code>scipy</code> sparse matrices, and other formats (coming soon). It would be nice to be able to read in from these formats as well.</li> <li>Graph-type handling: <code>networkframe</code> has mainly been tested on directed graphs, less so for undirected and multigraphs.</li> </ul>"},{"location":"#credits","title":"Credits","text":"<p>This package was created with Cookiecutter and the bdpedigo/cookiecutter-pypackage project template (which builds on several previous versions).</p>"},{"location":"api/","title":"Modules","text":"<p>Top-level package for networkframe.</p>"},{"location":"api/#networkframe.NetworkFrame","title":"<code>NetworkFrame</code>","text":"<p>Represent a network as a pair of dataframes, one for nodes and one for edges.</p>"},{"location":"api/#networkframe.NetworkFrame--parameters","title":"Parameters","text":"<p>nodes : pd.DataFrame     Table of node attributes, the node IDs are assumed to be the index edges : pd.DataFrame     Table of edges, with source and target columns which correspond with the node     Ids in the nodes dataframe. directed : bool, optional     Whether the network should be treated as directed, by default True sources : pd.Index, optional     Specification of source nodes if representing a subgraph, by default None targets : pd.Index, optional     Specification of target nodes if representing a subgraph, by default None</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>class NetworkFrame:\n    \"\"\"Represent a network as a pair of dataframes, one for nodes and one for edges.\n\n    Parameters\n    ----------\n    nodes : pd.DataFrame\n        Table of node attributes, the node IDs are assumed to be the index\n    edges : pd.DataFrame\n        Table of edges, with source and target columns which correspond with the node\n        Ids in the nodes dataframe.\n    directed : bool, optional\n        Whether the network should be treated as directed, by default True\n    sources : pd.Index, optional\n        Specification of source nodes if representing a subgraph, by default None\n    targets : pd.Index, optional\n        Specification of target nodes if representing a subgraph, by default None\n    \"\"\"\n\n    @beartype\n    def __init__(\n        self,\n        nodes: pd.DataFrame,\n        edges: pd.DataFrame,\n        directed: bool = True,\n        sources: Optional[pd.Index] = None,\n        targets: Optional[pd.Index] = None,\n    ):\n        # TODO checks ensuring that nodes and edges are valid.\n\n        if not nodes.index.is_unique:\n            raise ValueError(\"Node IDs must be unique.\")\n\n        referenced_node_ids = np.union1d(\n            edges[\"source\"].unique(), edges[\"target\"].unique()\n        )\n        if not np.all(np.isin(referenced_node_ids, nodes.index)):\n            raise ValueError(\"All nodes referenced in edges must be in nodes.\")\n\n        # should probably assume things like \"source\" and \"target\" columns\n        # and that these elements are in the nodes dataframe\n        # TODO are multigraphs allowed?\n        # TODO assert that sources and targets and node index are all unique?\n        self.nodes = nodes\n        self.edges = edges\n        if sources is None and targets is None:\n            self.induced = True\n            self._sources = None\n            self._targets = None\n        else:\n            self.induced = False\n            self._sources = sources\n            self._targets = targets\n        # TODO some checks on repeated edges if not directed\n        self.directed = directed\n\n    def copy(self) -&gt; \"NetworkFrame\":\n        \"\"\"Return a copy of the NetworkFrame.\"\"\"\n        return copy.deepcopy(self)\n\n    @property\n    def sources(self):\n        \"\"\"Return the source node IDs of the network.\"\"\"\n        if self.induced:\n            return self.nodes.index\n        else:\n            return self.nodes.index.intersection(self._sources, sort=False)\n            # all_sources = self.edges[\"source\"].unique()\n            # # TODO verify that this retains the order\n            # return self.nodes.index.intersection(all_sources, sort=False)\n\n    @property\n    def targets(self):\n        \"\"\"Return the target node IDs of the network.\"\"\"\n        if self.induced:\n            return self.nodes.index\n        else:\n            return self.nodes.index.intersection(self._targets, sort=False)\n            # all_targets = self.edges[\"target\"].unique()\n            # # TODO verify that this retains the order\n            # return self.nodes.index.intersection(all_targets, sort=False)\n\n    @property\n    def source_nodes(self):\n        \"\"\"Return the source nodes of the network and their metadata.\"\"\"\n        return self.nodes.loc[self.sources]\n\n    @property\n    def target_nodes(self):\n        \"\"\"Return the target nodes of the network and their metadata.\"\"\"\n        return self.nodes.loc[self.targets]\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of the NetworkFrame.\"\"\"\n        out = f\"NetworkFrame(nodes={self.nodes.shape}, edges={self.edges.shape}, \"\n        out += f\"induced={self.induced}, directed={self.directed})\"\n        return out\n\n    def reindex_nodes(self, index: pd.Index) -&gt; \"NetworkFrame\":\n        \"\"\"Reindex the nodes dataframe, also removes edges as necessary.\"\"\"\n        nodes = self.nodes.reindex(index=index, axis=0)\n        edges = self.edges.query(\"(source in @nodes.index) &amp; (target in @nodes.index)\")\n        return NetworkFrame(nodes, edges, directed=self.directed)\n\n    def remove_nodes(\n        self, nodes: Union[pd.DataFrame, pd.Index, list, np.ndarray], inplace=False\n    ) -&gt; Optional[\"NetworkFrame\"]:\n        \"\"\"Remove nodes from the network and remove edges that are no longer valid.\"\"\"\n        if isinstance(nodes, pd.DataFrame):\n            nodes = nodes.index\n        nodes = self.nodes.drop(index=nodes)\n        # get the edges that are connected to the nodes that are left after the query\n        edges = self.edges.query(\"(source in @nodes.index) &amp; (target in @nodes.index)\")\n        if inplace:\n            self.nodes = nodes\n            self.edges = edges\n            return None\n        else:\n            return NetworkFrame(nodes, edges, directed=self.directed)\n\n    def remove_edges(\n        self, remove_edges: pd.DataFrame, inplace=False\n    ) -&gt; Optional[\"NetworkFrame\"]:\n        \"\"\"Remove edges from the network.\"\"\"\n        # TODO handle inplace better\n\n        remove_edges_index = pd.MultiIndex.from_frame(\n            remove_edges[[\"source\", \"target\"]]\n        )\n        current_index = pd.MultiIndex.from_frame(self.edges[[\"source\", \"target\"]])\n        new_index = current_index.difference(remove_edges_index)\n\n        # TODO i think this destroys the old index?\n        edges = self.edges.set_index([\"source\", \"target\"]).loc[new_index].reset_index()\n        if inplace:\n            self.edges = edges\n            return None\n        else:\n            return NetworkFrame(self.nodes, edges, directed=self.directed)\n\n    def add_nodes(\n        self, new_nodes: pd.DataFrame, inplace=False\n    ) -&gt; Optional[\"NetworkFrame\"]:\n        \"\"\"Add nodes to the network.\"\"\"\n        nodes = pd.concat([self.nodes, new_nodes], copy=False, sort=False, axis=0)\n        if inplace:\n            self.nodes = nodes\n            return None\n        else:\n            return NetworkFrame(nodes, self.edges, directed=self.directed)\n\n    def add_edges(\n        self, new_edges: pd.DataFrame, inplace=False\n    ) -&gt; Optional[\"NetworkFrame\"]:\n        \"\"\"Add edges to the network.\"\"\"\n        edges = pd.concat([self.edges, new_edges], copy=False, sort=False, axis=0)\n        if inplace:\n            self.edges = edges\n            return None\n        else:\n            return NetworkFrame(self.nodes, edges, directed=self.directed)\n\n    def query_nodes(self, query: str, inplace=False) -&gt; Optional[\"NetworkFrame\"]:\n        \"\"\"Query the nodes dataframe and remove edges that are no longer valid.\"\"\"\n        nodes = self.nodes.query(query)\n        # get the edges that are connected to the nodes that are left after the query\n        edges = self.edges.query(\"(source in @nodes.index) &amp; (target in @nodes.index)\")\n        if inplace:\n            self.nodes = nodes\n            self.edges = edges\n            return None\n        else:\n            return NetworkFrame(nodes, edges, directed=self.directed)\n\n    def query_edges(self, query: str, inplace=False) -&gt; Optional[\"NetworkFrame\"]:\n        \"\"\"Query the edges dataframe.\"\"\"\n        edges = self.edges.query(query)\n        if inplace:\n            self.edges = edges\n            return None\n        else:\n            return NetworkFrame(self.nodes, edges, directed=self.directed)\n\n    def remove_unused_nodes(self, inplace=False) -&gt; Optional[\"NetworkFrame\"]:\n        \"\"\"Remove nodes that are not connected to any edges.\"\"\"\n        index = self.nodes.index\n        new_index = index.intersection(\n            self.edges.source.append(self.edges.target).unique()\n        )\n        nodes = self.nodes.loc[new_index]\n        if inplace:\n            self.nodes = nodes\n            return None\n        else:\n            return NetworkFrame(nodes, self.edges, directed=self.directed)\n\n    def apply_node_features(\n        self, columns: ColumnsType, axis: EdgeAxisType = \"both\", inplace=False\n    ) -&gt; Optional[\"NetworkFrame\"]:\n        \"\"\"Apply node features to the edges dataframe.\"\"\"\n        if not inplace:\n            edges = self.edges.copy()\n        else:\n            edges = self.edges\n        if isinstance(columns, str):\n            columns = [columns]\n        if axis in [\"source\", \"both\"]:\n            for col in columns:\n                edges[f\"source_{col}\"] = self.edges[\"source\"].map(self.nodes[col])\n        if axis in [\"target\", \"both\"]:\n            for col in columns:\n                edges[f\"target_{col}\"] = self.edges[\"target\"].map(self.nodes[col])\n        if inplace:\n            self.edges = edges\n            return None\n        else:\n            return NetworkFrame(self.nodes, edges, directed=self.directed)\n\n    def to_adjacency(self, weight_col: str = \"weight\", aggfunc=\"sum\") -&gt; pd.DataFrame:\n        \"\"\"Return the adjacency matrix of the network.\"\"\"\n        # TODO: wondering if the sparse method of doing this would actually be faster\n        # here too...\n        adj_df = self.edges.pivot_table(\n            index=\"source\",\n            columns=\"target\",\n            values=weight_col,\n            fill_value=0,\n            aggfunc=aggfunc,\n            sort=False,\n        )\n        adj_df = adj_df.reindex(\n            index=self.sources,\n            columns=self.targets,\n            fill_value=0,\n        )\n        adj_df.index = adj_df.index.set_names(\"source\")\n        adj_df.columns = adj_df.columns.set_names(\"target\")\n        return adj_df\n\n    def to_networkx(self):\n        \"\"\"Return a networkx graph of the network.\"\"\"\n        import networkx as nx\n\n        if self.directed:\n            create_using = nx.MultiDiGraph\n        else:\n            create_using = nx.MultiGraph\n\n        g = nx.from_pandas_edgelist(\n            self.edges,\n            source=\"source\",\n            target=\"target\",\n            edge_attr=True,\n            create_using=create_using,\n        )\n        nx.set_node_attributes(g, self.nodes.to_dict(orient=\"index\"))\n        return g\n\n    def to_sparse_adjacency(\n        self, weight_col: Optional[str] = None, aggfunc=\"sum\", verify_integrity=True\n    ) -&gt; csr_array:\n        \"\"\"Return the adjacency matrix of the network as a sparse array.\"\"\"\n        edges = self.edges\n        # TODO only necessary since there might be duplicate edges\n        # might be more efficient to have a attributed checking this, e.g. set whether\n        # this is a multigraph or not\n        if weight_col is not None:\n            effective_edges = edges.groupby([\"source\", \"target\"])[weight_col].agg(\n                aggfunc\n            )\n        else:\n            effective_edges = edges.groupby([\"source\", \"target\"]).size()\n\n        data = effective_edges.values\n        source_indices = effective_edges.index.get_level_values(\"source\")\n        target_indices = effective_edges.index.get_level_values(\"target\")\n\n        if verify_integrity:\n            if (\n                not np.isin(source_indices, self.nodes.index).all()\n                and not np.isin(target_indices, self.nodes.index).all()\n            ):\n                raise ValueError(\n                    \"Not all source and target indices are in the nodes index.\"\n                )\n\n        source_indices = pd.Categorical(source_indices, categories=self.nodes.index)\n        target_indices = pd.Categorical(target_indices, categories=self.nodes.index)\n\n        adj = csr_array(\n            (data, (source_indices.codes, target_indices.codes)),\n            shape=(len(self.sources), len(self.targets)),\n        )\n        return adj\n\n    def _get_component_indices(self) -&gt; tuple[int, np.ndarray]:\n        \"\"\"Helper function for connected_components.\"\"\"\n        from scipy.sparse.csgraph import connected_components\n\n        adjacency = self.to_sparse_adjacency()\n        n_components, labels = connected_components(adjacency, directed=self.directed)\n        return n_components, labels\n\n    def largest_connected_component(\n        self, inplace: bool = False, verbose: bool = False\n    ) -&gt; Optional[\"NetworkFrame\"]:\n        \"\"\"Return the largest connected component of the network.\"\"\"\n        _, labels = self._get_component_indices()\n        label_counts = pd.Series(labels).value_counts()\n        biggest_label = label_counts.idxmax()\n        mask = labels == biggest_label\n\n        if verbose:\n            n_removed = len(self.nodes) - mask.sum()\n            print(f\"Nodes removed when taking largest connected component: {n_removed}\")\n\n        nodes = self.nodes.iloc[mask]\n        edges = self.edges.query(\"(source in @nodes.index) &amp; (target in @nodes.index)\")\n\n        if inplace:\n            self.nodes = nodes\n            self.edges = edges\n            return None\n        else:\n            return NetworkFrame(nodes, edges, directed=self.directed)\n\n    def connected_components(self) -&gt; Iterator[\"NetworkFrame\"]:\n        \"\"\"Return the connected components of the network.\"\"\"\n        n_components, labels = self._get_component_indices()\n        index = self.nodes.index\n\n        for i in range(n_components):\n            this_index = index[labels == i]\n            yield self.loc[this_index, this_index]\n\n    def n_connected_components(self) -&gt; int:\n        \"\"\"Return the number of connected components of the network.\"\"\"\n        n_components, _ = self._get_component_indices()\n        return n_components\n\n    def is_fully_connected(self) -&gt; bool:\n        \"\"\"Return whether the network is fully connected.\"\"\"\n        return self.n_connected_components() == 1\n\n    def label_nodes_by_component(\n        self, inplace: bool = False, name: str = \"component\"\n    ) -&gt; Optional[\"NetworkFrame\"]:\n        \"\"\"Add a column labeling nodes by which connected component they are in.\"\"\"\n        _, labels = self._get_component_indices()\n\n        if inplace:\n            self.nodes[name] = labels\n            self.nodes[name] = self.nodes[name].astype(\"Int64\")\n            return None\n        else:\n            nodes = self.nodes.copy()\n            nodes[name] = labels\n            nodes[name] = nodes[name].astype(\"Int64\")\n            return NetworkFrame(nodes, self.edges, directed=self.directed)\n\n    def groupby_nodes(self, by=None, axis=\"both\", **kwargs) -&gt; \"NodeGroupBy\":\n        \"\"\"Group the frame by node data for the source or target (or both).\n\n        Parameters\n        ----------\n        by : _type_, optional\n            _description_, by default None\n        axis : str, optional\n            _description_, by default 'both'\n\n        Returns\n        -------\n        _type_\n            _description_\n\n        Raises\n        ------\n        ValueError\n            _description_\n        \"\"\"\n        if axis == 0:\n            source_nodes_groupby = self.source_nodes.groupby(by=by, **kwargs)\n        elif axis == 1:\n            target_nodes_groupby = self.target_nodes.groupby(by=by, **kwargs)\n        elif axis == \"both\":\n            source_nodes_groupby = self.source_nodes.groupby(by=by, **kwargs)\n            target_nodes_groupby = self.target_nodes.groupby(by=by, **kwargs)\n        else:\n            raise ValueError(\"Axis must be 0 or 1 or 'both'\")\n\n        return NodeGroupBy(self, source_nodes_groupby, target_nodes_groupby)\n\n    @property\n    def loc(self) -&gt; \"LocIndexer\":\n        \"\"\"Return a LocIndexer for the frame.\"\"\"\n        return LocIndexer(self)\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"\n        Check if two NetworkFrames are equal.\n\n        Note that this considers both node/edge names and features. It does not consider\n        the order of the nodes/edges. It does not consider the indexing of the edges.\n        This may change in a future release.\n        \"\"\"\n\n        if not isinstance(other, NetworkFrame):\n            return False\n\n        nodes1 = self.nodes\n        nodes2 = other.nodes\n        edges1 = self.edges\n        edges2 = other.edges\n        if not nodes1.sort_index().equals(nodes2.sort_index()):\n            return False\n        if (\n            not edges1.sort_values([\"source\", \"target\"])\n            .reset_index(drop=True)\n            .equals(edges2.sort_values([\"source\", \"target\"]).reset_index(drop=True))\n        ):\n            return False\n        return True\n\n    def __ne__(self, other: object) -&gt; bool:\n        \"\"\"\n        Check if two NetworkFrames are not equal.\n\n        Note that this considers both node/edge names and features. It does not consider\n        the order of the nodes/edges. It does not consider the indexing of the edges.\n        This may change in a future release.\n        \"\"\"\n        return not self.__eq__(other)\n\n    def to_dict(self, orient: str = \"dict\") -&gt; dict:\n        \"\"\"Return a dictionary representation of the NetworkFrame.\"\"\"\n        return {\n            \"nodes\": self.nodes.to_dict(orient=orient),\n            \"edges\": self.edges.to_dict(orient=orient),\n            \"directed\": self.directed,\n        }\n\n    def to_json(self, orient: str = \"dict\") -&gt; str:\n        \"\"\"Return a JSON representation of the NetworkFrame.\"\"\"\n        import json\n\n        return json.dumps(self.to_dict(orient=orient))\n\n    @classmethod\n    def from_dict(cls, d: dict, orient=\"columns\", index_dtype=int) -&gt; \"NetworkFrame\":\n        \"\"\"Return a NetworkFrame from a dictionary representation.\"\"\"\n        edges = pd.DataFrame.from_dict(d[\"edges\"], orient=orient)\n        nodes = pd.DataFrame.from_dict(d[\"nodes\"], orient=orient)\n        nodes.index = nodes.index.astype(index_dtype)\n        return cls(\n            nodes,\n            edges,\n            directed=d[\"directed\"],\n        )\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.loc","title":"<code>loc: LocIndexer</code>  <code>property</code>","text":"<p>Return a LocIndexer for the frame.</p>"},{"location":"api/#networkframe.NetworkFrame.source_nodes","title":"<code>source_nodes</code>  <code>property</code>","text":"<p>Return the source nodes of the network and their metadata.</p>"},{"location":"api/#networkframe.NetworkFrame.sources","title":"<code>sources</code>  <code>property</code>","text":"<p>Return the source node IDs of the network.</p>"},{"location":"api/#networkframe.NetworkFrame.target_nodes","title":"<code>target_nodes</code>  <code>property</code>","text":"<p>Return the target nodes of the network and their metadata.</p>"},{"location":"api/#networkframe.NetworkFrame.targets","title":"<code>targets</code>  <code>property</code>","text":"<p>Return the target node IDs of the network.</p>"},{"location":"api/#networkframe.NetworkFrame.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check if two NetworkFrames are equal.</p> <p>Note that this considers both node/edge names and features. It does not consider the order of the nodes/edges. It does not consider the indexing of the edges. This may change in a future release.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"\n    Check if two NetworkFrames are equal.\n\n    Note that this considers both node/edge names and features. It does not consider\n    the order of the nodes/edges. It does not consider the indexing of the edges.\n    This may change in a future release.\n    \"\"\"\n\n    if not isinstance(other, NetworkFrame):\n        return False\n\n    nodes1 = self.nodes\n    nodes2 = other.nodes\n    edges1 = self.edges\n    edges2 = other.edges\n    if not nodes1.sort_index().equals(nodes2.sort_index()):\n        return False\n    if (\n        not edges1.sort_values([\"source\", \"target\"])\n        .reset_index(drop=True)\n        .equals(edges2.sort_values([\"source\", \"target\"]).reset_index(drop=True))\n    ):\n        return False\n    return True\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Check if two NetworkFrames are not equal.</p> <p>Note that this considers both node/edge names and features. It does not consider the order of the nodes/edges. It does not consider the indexing of the edges. This may change in a future release.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def __ne__(self, other: object) -&gt; bool:\n    \"\"\"\n    Check if two NetworkFrames are not equal.\n\n    Note that this considers both node/edge names and features. It does not consider\n    the order of the nodes/edges. It does not consider the indexing of the edges.\n    This may change in a future release.\n    \"\"\"\n    return not self.__eq__(other)\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the NetworkFrame.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the NetworkFrame.\"\"\"\n    out = f\"NetworkFrame(nodes={self.nodes.shape}, edges={self.edges.shape}, \"\n    out += f\"induced={self.induced}, directed={self.directed})\"\n    return out\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.add_edges","title":"<code>add_edges(new_edges, inplace=False)</code>","text":"<p>Add edges to the network.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def add_edges(\n    self, new_edges: pd.DataFrame, inplace=False\n) -&gt; Optional[\"NetworkFrame\"]:\n    \"\"\"Add edges to the network.\"\"\"\n    edges = pd.concat([self.edges, new_edges], copy=False, sort=False, axis=0)\n    if inplace:\n        self.edges = edges\n        return None\n    else:\n        return NetworkFrame(self.nodes, edges, directed=self.directed)\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.add_nodes","title":"<code>add_nodes(new_nodes, inplace=False)</code>","text":"<p>Add nodes to the network.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def add_nodes(\n    self, new_nodes: pd.DataFrame, inplace=False\n) -&gt; Optional[\"NetworkFrame\"]:\n    \"\"\"Add nodes to the network.\"\"\"\n    nodes = pd.concat([self.nodes, new_nodes], copy=False, sort=False, axis=0)\n    if inplace:\n        self.nodes = nodes\n        return None\n    else:\n        return NetworkFrame(nodes, self.edges, directed=self.directed)\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.apply_node_features","title":"<code>apply_node_features(columns, axis='both', inplace=False)</code>","text":"<p>Apply node features to the edges dataframe.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def apply_node_features(\n    self, columns: ColumnsType, axis: EdgeAxisType = \"both\", inplace=False\n) -&gt; Optional[\"NetworkFrame\"]:\n    \"\"\"Apply node features to the edges dataframe.\"\"\"\n    if not inplace:\n        edges = self.edges.copy()\n    else:\n        edges = self.edges\n    if isinstance(columns, str):\n        columns = [columns]\n    if axis in [\"source\", \"both\"]:\n        for col in columns:\n            edges[f\"source_{col}\"] = self.edges[\"source\"].map(self.nodes[col])\n    if axis in [\"target\", \"both\"]:\n        for col in columns:\n            edges[f\"target_{col}\"] = self.edges[\"target\"].map(self.nodes[col])\n    if inplace:\n        self.edges = edges\n        return None\n    else:\n        return NetworkFrame(self.nodes, edges, directed=self.directed)\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.connected_components","title":"<code>connected_components()</code>","text":"<p>Return the connected components of the network.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def connected_components(self) -&gt; Iterator[\"NetworkFrame\"]:\n    \"\"\"Return the connected components of the network.\"\"\"\n    n_components, labels = self._get_component_indices()\n    index = self.nodes.index\n\n    for i in range(n_components):\n        this_index = index[labels == i]\n        yield self.loc[this_index, this_index]\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.copy","title":"<code>copy()</code>","text":"<p>Return a copy of the NetworkFrame.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def copy(self) -&gt; \"NetworkFrame\":\n    \"\"\"Return a copy of the NetworkFrame.\"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.from_dict","title":"<code>from_dict(d, orient='columns', index_dtype=int)</code>  <code>classmethod</code>","text":"<p>Return a NetworkFrame from a dictionary representation.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>@classmethod\ndef from_dict(cls, d: dict, orient=\"columns\", index_dtype=int) -&gt; \"NetworkFrame\":\n    \"\"\"Return a NetworkFrame from a dictionary representation.\"\"\"\n    edges = pd.DataFrame.from_dict(d[\"edges\"], orient=orient)\n    nodes = pd.DataFrame.from_dict(d[\"nodes\"], orient=orient)\n    nodes.index = nodes.index.astype(index_dtype)\n    return cls(\n        nodes,\n        edges,\n        directed=d[\"directed\"],\n    )\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.groupby_nodes","title":"<code>groupby_nodes(by=None, axis='both', **kwargs)</code>","text":"<p>Group the frame by node data for the source or target (or both).</p>"},{"location":"api/#networkframe.NetworkFrame.groupby_nodes--parameters","title":"Parameters","text":"<p>by : type, optional     description, by default None axis : str, optional     description, by default 'both'</p>"},{"location":"api/#networkframe.NetworkFrame.groupby_nodes--returns","title":"Returns","text":"<p>type description</p>"},{"location":"api/#networkframe.NetworkFrame.groupby_nodes--raises","title":"Raises","text":"<p>ValueError     description</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def groupby_nodes(self, by=None, axis=\"both\", **kwargs) -&gt; \"NodeGroupBy\":\n    \"\"\"Group the frame by node data for the source or target (or both).\n\n    Parameters\n    ----------\n    by : _type_, optional\n        _description_, by default None\n    axis : str, optional\n        _description_, by default 'both'\n\n    Returns\n    -------\n    _type_\n        _description_\n\n    Raises\n    ------\n    ValueError\n        _description_\n    \"\"\"\n    if axis == 0:\n        source_nodes_groupby = self.source_nodes.groupby(by=by, **kwargs)\n    elif axis == 1:\n        target_nodes_groupby = self.target_nodes.groupby(by=by, **kwargs)\n    elif axis == \"both\":\n        source_nodes_groupby = self.source_nodes.groupby(by=by, **kwargs)\n        target_nodes_groupby = self.target_nodes.groupby(by=by, **kwargs)\n    else:\n        raise ValueError(\"Axis must be 0 or 1 or 'both'\")\n\n    return NodeGroupBy(self, source_nodes_groupby, target_nodes_groupby)\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.is_fully_connected","title":"<code>is_fully_connected()</code>","text":"<p>Return whether the network is fully connected.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def is_fully_connected(self) -&gt; bool:\n    \"\"\"Return whether the network is fully connected.\"\"\"\n    return self.n_connected_components() == 1\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.label_nodes_by_component","title":"<code>label_nodes_by_component(inplace=False, name='component')</code>","text":"<p>Add a column labeling nodes by which connected component they are in.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def label_nodes_by_component(\n    self, inplace: bool = False, name: str = \"component\"\n) -&gt; Optional[\"NetworkFrame\"]:\n    \"\"\"Add a column labeling nodes by which connected component they are in.\"\"\"\n    _, labels = self._get_component_indices()\n\n    if inplace:\n        self.nodes[name] = labels\n        self.nodes[name] = self.nodes[name].astype(\"Int64\")\n        return None\n    else:\n        nodes = self.nodes.copy()\n        nodes[name] = labels\n        nodes[name] = nodes[name].astype(\"Int64\")\n        return NetworkFrame(nodes, self.edges, directed=self.directed)\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.largest_connected_component","title":"<code>largest_connected_component(inplace=False, verbose=False)</code>","text":"<p>Return the largest connected component of the network.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def largest_connected_component(\n    self, inplace: bool = False, verbose: bool = False\n) -&gt; Optional[\"NetworkFrame\"]:\n    \"\"\"Return the largest connected component of the network.\"\"\"\n    _, labels = self._get_component_indices()\n    label_counts = pd.Series(labels).value_counts()\n    biggest_label = label_counts.idxmax()\n    mask = labels == biggest_label\n\n    if verbose:\n        n_removed = len(self.nodes) - mask.sum()\n        print(f\"Nodes removed when taking largest connected component: {n_removed}\")\n\n    nodes = self.nodes.iloc[mask]\n    edges = self.edges.query(\"(source in @nodes.index) &amp; (target in @nodes.index)\")\n\n    if inplace:\n        self.nodes = nodes\n        self.edges = edges\n        return None\n    else:\n        return NetworkFrame(nodes, edges, directed=self.directed)\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.n_connected_components","title":"<code>n_connected_components()</code>","text":"<p>Return the number of connected components of the network.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def n_connected_components(self) -&gt; int:\n    \"\"\"Return the number of connected components of the network.\"\"\"\n    n_components, _ = self._get_component_indices()\n    return n_components\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.query_edges","title":"<code>query_edges(query, inplace=False)</code>","text":"<p>Query the edges dataframe.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def query_edges(self, query: str, inplace=False) -&gt; Optional[\"NetworkFrame\"]:\n    \"\"\"Query the edges dataframe.\"\"\"\n    edges = self.edges.query(query)\n    if inplace:\n        self.edges = edges\n        return None\n    else:\n        return NetworkFrame(self.nodes, edges, directed=self.directed)\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.query_nodes","title":"<code>query_nodes(query, inplace=False)</code>","text":"<p>Query the nodes dataframe and remove edges that are no longer valid.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def query_nodes(self, query: str, inplace=False) -&gt; Optional[\"NetworkFrame\"]:\n    \"\"\"Query the nodes dataframe and remove edges that are no longer valid.\"\"\"\n    nodes = self.nodes.query(query)\n    # get the edges that are connected to the nodes that are left after the query\n    edges = self.edges.query(\"(source in @nodes.index) &amp; (target in @nodes.index)\")\n    if inplace:\n        self.nodes = nodes\n        self.edges = edges\n        return None\n    else:\n        return NetworkFrame(nodes, edges, directed=self.directed)\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.reindex_nodes","title":"<code>reindex_nodes(index)</code>","text":"<p>Reindex the nodes dataframe, also removes edges as necessary.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def reindex_nodes(self, index: pd.Index) -&gt; \"NetworkFrame\":\n    \"\"\"Reindex the nodes dataframe, also removes edges as necessary.\"\"\"\n    nodes = self.nodes.reindex(index=index, axis=0)\n    edges = self.edges.query(\"(source in @nodes.index) &amp; (target in @nodes.index)\")\n    return NetworkFrame(nodes, edges, directed=self.directed)\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.remove_edges","title":"<code>remove_edges(remove_edges, inplace=False)</code>","text":"<p>Remove edges from the network.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def remove_edges(\n    self, remove_edges: pd.DataFrame, inplace=False\n) -&gt; Optional[\"NetworkFrame\"]:\n    \"\"\"Remove edges from the network.\"\"\"\n    # TODO handle inplace better\n\n    remove_edges_index = pd.MultiIndex.from_frame(\n        remove_edges[[\"source\", \"target\"]]\n    )\n    current_index = pd.MultiIndex.from_frame(self.edges[[\"source\", \"target\"]])\n    new_index = current_index.difference(remove_edges_index)\n\n    # TODO i think this destroys the old index?\n    edges = self.edges.set_index([\"source\", \"target\"]).loc[new_index].reset_index()\n    if inplace:\n        self.edges = edges\n        return None\n    else:\n        return NetworkFrame(self.nodes, edges, directed=self.directed)\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.remove_nodes","title":"<code>remove_nodes(nodes, inplace=False)</code>","text":"<p>Remove nodes from the network and remove edges that are no longer valid.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def remove_nodes(\n    self, nodes: Union[pd.DataFrame, pd.Index, list, np.ndarray], inplace=False\n) -&gt; Optional[\"NetworkFrame\"]:\n    \"\"\"Remove nodes from the network and remove edges that are no longer valid.\"\"\"\n    if isinstance(nodes, pd.DataFrame):\n        nodes = nodes.index\n    nodes = self.nodes.drop(index=nodes)\n    # get the edges that are connected to the nodes that are left after the query\n    edges = self.edges.query(\"(source in @nodes.index) &amp; (target in @nodes.index)\")\n    if inplace:\n        self.nodes = nodes\n        self.edges = edges\n        return None\n    else:\n        return NetworkFrame(nodes, edges, directed=self.directed)\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.remove_unused_nodes","title":"<code>remove_unused_nodes(inplace=False)</code>","text":"<p>Remove nodes that are not connected to any edges.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def remove_unused_nodes(self, inplace=False) -&gt; Optional[\"NetworkFrame\"]:\n    \"\"\"Remove nodes that are not connected to any edges.\"\"\"\n    index = self.nodes.index\n    new_index = index.intersection(\n        self.edges.source.append(self.edges.target).unique()\n    )\n    nodes = self.nodes.loc[new_index]\n    if inplace:\n        self.nodes = nodes\n        return None\n    else:\n        return NetworkFrame(nodes, self.edges, directed=self.directed)\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.to_adjacency","title":"<code>to_adjacency(weight_col='weight', aggfunc='sum')</code>","text":"<p>Return the adjacency matrix of the network.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def to_adjacency(self, weight_col: str = \"weight\", aggfunc=\"sum\") -&gt; pd.DataFrame:\n    \"\"\"Return the adjacency matrix of the network.\"\"\"\n    # TODO: wondering if the sparse method of doing this would actually be faster\n    # here too...\n    adj_df = self.edges.pivot_table(\n        index=\"source\",\n        columns=\"target\",\n        values=weight_col,\n        fill_value=0,\n        aggfunc=aggfunc,\n        sort=False,\n    )\n    adj_df = adj_df.reindex(\n        index=self.sources,\n        columns=self.targets,\n        fill_value=0,\n    )\n    adj_df.index = adj_df.index.set_names(\"source\")\n    adj_df.columns = adj_df.columns.set_names(\"target\")\n    return adj_df\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.to_dict","title":"<code>to_dict(orient='dict')</code>","text":"<p>Return a dictionary representation of the NetworkFrame.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def to_dict(self, orient: str = \"dict\") -&gt; dict:\n    \"\"\"Return a dictionary representation of the NetworkFrame.\"\"\"\n    return {\n        \"nodes\": self.nodes.to_dict(orient=orient),\n        \"edges\": self.edges.to_dict(orient=orient),\n        \"directed\": self.directed,\n    }\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.to_json","title":"<code>to_json(orient='dict')</code>","text":"<p>Return a JSON representation of the NetworkFrame.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def to_json(self, orient: str = \"dict\") -&gt; str:\n    \"\"\"Return a JSON representation of the NetworkFrame.\"\"\"\n    import json\n\n    return json.dumps(self.to_dict(orient=orient))\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.to_networkx","title":"<code>to_networkx()</code>","text":"<p>Return a networkx graph of the network.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def to_networkx(self):\n    \"\"\"Return a networkx graph of the network.\"\"\"\n    import networkx as nx\n\n    if self.directed:\n        create_using = nx.MultiDiGraph\n    else:\n        create_using = nx.MultiGraph\n\n    g = nx.from_pandas_edgelist(\n        self.edges,\n        source=\"source\",\n        target=\"target\",\n        edge_attr=True,\n        create_using=create_using,\n    )\n    nx.set_node_attributes(g, self.nodes.to_dict(orient=\"index\"))\n    return g\n</code></pre>"},{"location":"api/#networkframe.NetworkFrame.to_sparse_adjacency","title":"<code>to_sparse_adjacency(weight_col=None, aggfunc='sum', verify_integrity=True)</code>","text":"<p>Return the adjacency matrix of the network as a sparse array.</p> Source code in <code>networkframe/networkframe.py</code> <pre><code>def to_sparse_adjacency(\n    self, weight_col: Optional[str] = None, aggfunc=\"sum\", verify_integrity=True\n) -&gt; csr_array:\n    \"\"\"Return the adjacency matrix of the network as a sparse array.\"\"\"\n    edges = self.edges\n    # TODO only necessary since there might be duplicate edges\n    # might be more efficient to have a attributed checking this, e.g. set whether\n    # this is a multigraph or not\n    if weight_col is not None:\n        effective_edges = edges.groupby([\"source\", \"target\"])[weight_col].agg(\n            aggfunc\n        )\n    else:\n        effective_edges = edges.groupby([\"source\", \"target\"]).size()\n\n    data = effective_edges.values\n    source_indices = effective_edges.index.get_level_values(\"source\")\n    target_indices = effective_edges.index.get_level_values(\"target\")\n\n    if verify_integrity:\n        if (\n            not np.isin(source_indices, self.nodes.index).all()\n            and not np.isin(target_indices, self.nodes.index).all()\n        ):\n            raise ValueError(\n                \"Not all source and target indices are in the nodes index.\"\n            )\n\n    source_indices = pd.Categorical(source_indices, categories=self.nodes.index)\n    target_indices = pd.Categorical(target_indices, categories=self.nodes.index)\n\n    adj = csr_array(\n        (data, (source_indices.codes, target_indices.codes)),\n        shape=(len(self.sources), len(self.targets)),\n    )\n    return adj\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#fix","title":"Fix","text":"<ul> <li>correct something</li> </ul>"},{"location":"changelog/#v031-2023-12-14","title":"v0.3.1 (2023-12-14)","text":""},{"location":"changelog/#fix_1","title":"Fix","text":"<ul> <li>fix improper commitizen spec</li> </ul>"},{"location":"changelog/#v030-2023-12-14","title":"v0.3.0 (2023-12-14)","text":""},{"location":"changelog/#v021-2023-12-13","title":"v0.2.1 (2023-12-13)","text":""},{"location":"changelog/#v020-2023-12-13","title":"v0.2.0 (2023-12-13)","text":""},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/bdpedigo/networkframe/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>networkframe could always use more documentation, whether as part of the official networkframe docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/bdpedigo/networkframe/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome.</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started","text":"<p>Ready to contribute? Here's how to set up <code>networkframe</code> for local development.</p> <ol> <li>Fork the <code>networkframe</code> repo on GitHub.</li> <li>Clone your fork locally</li> </ol> <pre><code>git clone git@github.com:your_name_here/networkframe.git\n</code></pre> <ol> <li>Ensure poetry is installed.</li> <li>Install dependencies and start your virtualenv:</li> </ol> <pre><code>poetry install --with dev\n</code></pre> <ol> <li>Create a branch for local development:</li> </ol> <pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> <ol> <li>When you're done making changes, check that your changes pass the    tests, including testing other Python versions, with tox:</li> </ol> <pre><code>poetry run tox\n</code></pre> <ol> <li>Commit your changes and push your branch to GitHub:</li> </ol> <pre><code>git add .\ngit commit -m \"Your detailed description of your changes.\"\ngit push origin name-of-your-bugfix-or-feature\n</code></pre> <ol> <li>Submit a pull request through the GitHub website.</li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put    your new functionality into a function with a docstring, and add the    feature to the list in README.md.</li> <li>Check https://github.com/bdpedigo/networkframe/actions    and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"contributing/#tips","title":"Tips","text":"<pre><code>poetry run pytest tests/test_networkframe.py\n</code></pre> <p>To run a subset of tests.</p>"},{"location":"contributing/#deploying","title":"Deploying","text":"<p>A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md). Then run:</p> <pre><code>poetry run bump2version patch # possible: major / minor / patch\ngit push\ngit push --tags\n</code></pre> <p>GitHub Actions will then deploy to PyPI if tests pass.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install <code>networkframe</code>, run this command in your terminal:</p> <pre><code>pip install networkframe\n</code></pre> <p>This is the preferred method to install <code>networkframe</code>, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-source","title":"From source","text":"<p>The source for <code>networkframe</code> can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>git clone git://github.com/bdpedigo/networkframe\n</code></pre> <p>Or download the tarball:</p> <pre><code>curl -OJL https://github.com/bdpedigo/networkframe/tarball/master\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>pip install .\n</code></pre> <p>Or in editable mode, it can be installed with:</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#usage","title":"Usage","text":"<p>To use <code>networkframe</code> in a project</p> <pre><code>import networkframe\n</code></pre>"}]}