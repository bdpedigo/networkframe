{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#networkframe","title":"<code>networkframe</code>","text":"<p>Lightweight representations of networks using Pandas DataFrames.</p> <ul> <li>Documentation: https://bdpedigo.github.io/networkframe</li> <li>GitHub: https://github.com/bdpedigo/networkframe</li> <li>PyPI: https://pypi.org/project/networkframe/</li> <li>Free software: MIT</li> </ul> <p><code>networkframe</code> uses Pandas DataFrames to represent networks in a lightweight way. A <code>NetworkFrame</code> object is simply a table representing nodes and a table representing edges, and a variety of methods to make querying and manipulating that data easy.</p> <p>Warning: <code>networkframe</code> is still in early development, so there may be bugs and missing features. Please report any issues you find!</p>"},{"location":"#examples","title":"Examples","text":"<p>Creating a <code>NetworkFrame</code> from scratch:</p> <pre><code>import pandas as pd\n\nfrom networkframe import NetworkFrame\n\nnodes = pd.DataFrame(\n    {\n        \"name\": [\"A\", \"B\", \"C\", \"D\", \"E\"],\n        \"color\": [\"red\", \"blue\", \"blue\", \"red\", \"blue\"],\n    },\n    index=[0, 1, 2, 3, 4],\n)\nedges = pd.DataFrame(\n    {\n        \"source\": [0, 1, 2, 2, 3],\n        \"target\": [1, 2, 3, 1, 0],\n        \"weight\": [1, 2, 3, 4, 5],\n    }\n)\n\nnf = NetworkFrame(nodes, edges)\nprint(nf)\n</code></pre> <pre><code>NetworkFrame(nodes=(5, 2), edges=(5, 3))\n</code></pre> <p>Selecting a subgraph by node color</p> <pre><code>red_nodes = nf.query_nodes(\"color == 'red'\")\nprint(red_nodes.nodes)\n</code></pre> <pre><code>  name color\n0    A   red\n3    D   red\n</code></pre> <p>Selecting a subgraph by edge weight</p> <pre><code>strong_nf = nf.query_edges(\"weight &gt; 2\")\nprint(strong_nf.edges)\n</code></pre> <pre><code>   source  target  weight\n2       2       3       3\n3       2       1       4\n4       3       0       5\n</code></pre> <p>Iterating over subgraphs by node color</p> <pre><code>for color, subgraph in nf.groupby_nodes(\"color\", axis=\"both\"):\n    print(color)\n    print(subgraph.edges)\n</code></pre> <pre><code>('blue', 'blue')\n   source  target  weight\n1       1       2       2\n3       2       1       4\n('blue', 'red')\n   source  target  weight\n2       2       3       3\n('red', 'blue')\n   source  target  weight\n0       0       1       1\n('red', 'red')\n   source  target  weight\n4       3       0       5\n</code></pre> <p>Applying node information to edges</p> <pre><code>nf.apply_node_features(\"color\", inplace=True)\nprint(nf.edges)\n</code></pre> <pre><code>   source  target  weight source_color target_color\n0       0       1       1          red         blue\n1       1       2       2         blue         blue\n2       2       3       3         blue          red\n3       2       1       4         blue         blue\n4       3       0       5          red          red\n</code></pre>"},{"location":"#is-networkframe-right-for-you","title":"Is <code>networkframe</code> right for you?","text":"<p>Pros:</p> <ul> <li>Lightweight: <code>NetworkFrame</code> objects are just two DataFrames, so they're easy to manipulate and integrate with other tools.</li> <li>Interoperable: can output to <code>NetworkX</code>, <code>numpy</code> arrays, and <code>scipy</code> sparse arrays.</li> <li>Flexible: can represent directed, undirected, and multigraphs.</li> <li>Familiar: if you're familiar with <code>Pandas</code> <code>DataFrames</code>, that is. As much as possible, <code>networkframe</code> uses the same syntax as <code>Pandas</code>, but also just gives you access to the underlying tables.</li> <li>Extensible: it's easy to use <code>NetworkFrame</code> as a base graph - for instance, you could make a <code>SpatialNetworkFrame</code> that adds spatial information to the nodes and edges.</li> </ul> <p>Cons:</p> <ul> <li>No guarantees: since <code>networkframe</code> gives you access to the underlying <code>DataFrames</code>, it doesn't do much validation of the data. This is by design, to keep it lightweight and flexible, but it means you can also mess up a <code>NetworkFrame</code> if you aren't careful (for instance, you could delete the index used to map edges to nodes).</li> <li>Not optimized for graph computations: since <code>networkframe</code> is storing data as simple node and edge tables, it's not optimized for doing actual computations on those graphs (e.g. like searching for shortest paths). A typical workflow would be to use <code>networkframe</code> to load and manipulate your data, then convert to a more graph-oriented format like <code>scipy</code> sparse matrices or <code>NetworkX</code> for computations.</li> </ul> <p>Room for improvement:</p> <ul> <li>Early development: there are likely bugs and missing features. Please report any issues you find!</li> <li>More interoperability: <code>networkframe</code> can currently output to <code>NetworkX</code>, <code>numpy</code>, and <code>scipy</code> sparse arrays. It would be nice to be able to read in from these formats in a more convenient way, and ouput to other formats like <code>igraph</code> or <code>graph-tool</code>.</li> <li>Graph-type handling: <code>networkframe</code> has mainly been tested on directed graphs, less so for undirected and multigraphs.</li> </ul>"},{"location":"#credits","title":"Credits","text":"<p>This package was created with Cookiecutter and the bdpedigo/cookiecutter-pypackage project template (which builds on several previous versions).</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#fix","title":"Fix","text":"<ul> <li>correct something</li> </ul>"},{"location":"changelog/#v031-2023-12-14","title":"v0.3.1 (2023-12-14)","text":""},{"location":"changelog/#fix_1","title":"Fix","text":"<ul> <li>fix improper commitizen spec</li> </ul>"},{"location":"changelog/#v030-2023-12-14","title":"v0.3.0 (2023-12-14)","text":""},{"location":"changelog/#v021-2023-12-13","title":"v0.2.1 (2023-12-13)","text":""},{"location":"changelog/#v020-2023-12-13","title":"v0.2.0 (2023-12-13)","text":""},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/bdpedigo/networkframe/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>networkframe could always use more documentation, whether as part of the official networkframe docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/bdpedigo/networkframe/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome.</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started","text":"<p>Ready to contribute? Here's how to set up <code>networkframe</code> for local development.</p> <ol> <li>Fork the <code>networkframe</code> repo on GitHub.</li> <li>Clone your fork locally</li> </ol> <pre><code>git clone git@github.com:your_name_here/networkframe.git\n</code></pre> <ol> <li>Ensure poetry is installed.</li> <li>Install dependencies and start your virtualenv:</li> </ol> <pre><code>poetry install --with dev\n</code></pre> <ol> <li>Create a branch for local development:</li> </ol> <pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> <ol> <li>When you're done making changes, check that your changes pass the    tests, including testing other Python versions, with tox:</li> </ol> <pre><code>poetry run tox\n</code></pre> <ol> <li>Commit your changes and push your branch to GitHub:</li> </ol> <pre><code>git add .\ngit commit -m \"Your detailed description of your changes.\"\ngit push origin name-of-your-bugfix-or-feature\n</code></pre> <ol> <li>Submit a pull request through the GitHub website.</li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put    your new functionality into a function with a docstring, and add the    feature to the list in README.md.</li> <li>Check https://github.com/bdpedigo/networkframe/actions    and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"contributing/#tips","title":"Tips","text":"<pre><code>poetry run pytest tests/test_networkframe.py\n</code></pre> <p>To run a subset of tests.</p>"},{"location":"contributing/#deploying","title":"Deploying","text":"<p>A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md). Then run:</p> <pre><code>poetry run bump2version patch # possible: major / minor / patch\ngit push\ngit push --tags\n</code></pre> <p>GitHub Actions will then deploy to PyPI if tests pass.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install <code>networkframe</code>, run this command in your terminal:</p> <pre><code>pip install networkframe\n</code></pre> <p>This is the preferred method to install <code>networkframe</code>, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-source","title":"From source","text":"<p>The source for <code>networkframe</code> can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>git clone git://github.com/bdpedigo/networkframe\n</code></pre> <p>Or download the tarball:</p> <pre><code>curl -OJL https://github.com/bdpedigo/networkframe/tarball/master\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>pip install .\n</code></pre> <p>Or in editable mode, it can be installed with:</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#usage","title":"Usage","text":"<p>To use <code>networkframe</code> in a project</p> <pre><code>import networkframe\n</code></pre>"},{"location":"reference/networkframe/","title":"NetworkFrame","text":""},{"location":"reference/networkframe/#networkframe.NetworkFrame","title":"<code>networkframe.NetworkFrame(nodes, edges, directed=True, sources=None, targets=None, validate=True, induced=True)</code>","text":"<p>Represent a network as a pair of DataFrames, one for nodes and one for edges.</p> PARAMETER  DESCRIPTION <code>nodes</code> <p>Table of node attributes. The node IDs must be in the index.</p> <p> TYPE: <code>DataFrame</code> </p> <code>edges</code> <p>Table of edges, with source and target columns which correspond with the node IDs in<code>nodes.index</code>.</p> <p> TYPE: <code>DataFrame</code> </p> <code>directed</code> <p>Whether the network should be treated as directed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>sources</code> <p>Specification of source nodes if representing a subgraph.</p> <p> TYPE: <code>Optional[Index]</code> DEFAULT: <code>None</code> </p> <code>targets</code> <p>Specification of target nodes if representing a subgraph.</p> <p> TYPE: <code>Optional[Index]</code> DEFAULT: <code>None</code> </p> <code>validate</code> <p>Whether to check that the nodes and edges are valid. This can be turned off to speed performance but risks causing errors later on.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>induced</code> <p>Whether the network is induced, i.e. whether the nodes and edges are specified as a subgraph of a larger network. Currently non-functional, subject to some API changes in the future.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.loc","title":"<code>loc: LocIndexer</code>  <code>property</code>","text":"<p>Access a subgraph by node ID(s).</p> <p><code>.loc[]</code> is primarily label based, but in the future a boolean array may be supported. Currently, <code>.loc</code> only supports selecting both rows and columns, i.e. <code>nf.loc[row_indexer, column_indexer]</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from networkframe import NetworkFrame\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; nodes = pd.DataFrame(\n...     {\n...         \"name\": [\"A\", \"B\", \"C\", \"D\", \"E\"],\n...         \"color\": [\"red\", \"blue\", \"blue\", \"red\", \"blue\"],\n...     },\n...     index=[0, 1, 2, 3, 4],\n... )\n&gt;&gt;&gt; edges = pd.DataFrame(\n...     {\n...         \"source\": [0, 1, 2, 3, 4],\n...         \"target\": [1, 2, 3, 4, 0],\n...         \"weight\": [1, 2, 3, 4, 5],\n...     }\n... )\n&gt;&gt;&gt; nf = NetworkFrame(nodes, edges)\n&gt;&gt;&gt; sub_nf = nf.loc[[1, 2], [2, 3]]\n&gt;&gt;&gt; sub_nf\nNetworkFrame(nodes=(3, 1), edges=(2, 3))\n&gt;&gt;&gt; sub_nf.to_adjacency()\ntarget  2  3\nsource\n1       2  0\n2       0  3\n</code></pre>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check if two NetworkFrames are equal.</p> <p>Note that this considers both node/edge names and features. It does not consider the order of the nodes/edges. It does not consider the indexing of the edges. This may change in a future release.</p>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of nodes in the network.</p> RETURNS DESCRIPTION <code>int</code> <p>The number of nodes in the network.</p>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Check if two NetworkFrames are not equal.</p> <p>Note that this considers both node/edge names and features. It does not consider the order of the nodes/edges. It does not consider the indexing of the edges. This may change in a future release.</p>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the NetworkFrame.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of the NetworkFrame.</p>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.apply_node_features","title":"<code>apply_node_features(columns, axis='both', inplace=False)</code>","text":"<p>Apply features from <code>.nodes</code> to <code>.edges</code>.</p> <p>This will create new columns in <code>.edges</code> with the node features of the source node as <code>\"source_{column}\"</code> and the node features of the target node as <code>\"target_{column}\"</code>. This can be useful for performing operations on edges based on the nodes they connect.</p> PARAMETER  DESCRIPTION <code>columns</code> <p>The columns in <code>.nodes</code> to apply to the edges.</p> <p> TYPE: <code>ColumnsType</code> </p> <code>axis</code> <p>Whether to apply the features to the source nodes (<code>source</code>), target nodes (<code>target</code>), or both (<code>both</code>).</p> <p> TYPE: <code>EdgeAxisType</code> DEFAULT: <code>'both'</code> </p> <code>inplace</code> <p>Whether to modify the <code>NetworkFrame</code> rather than returning a new one.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Optional[Self]</code> <p>A new NetworkFrame with the node features applied to the edges. If <code>inplace=True</code>, returns <code>None</code>.</p>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.component_labels","title":"<code>component_labels(directed=True, connection='weak')</code>","text":"<p>Return the indices of the connected components.</p> PARAMETER  DESCRIPTION <code>directed</code> <p>If True (default), then operate on a directed graph: only move from point <code>i</code> to point <code>j</code> along edges from <code>i</code> to <code>j</code>. If False, then compute components on an undirected graph: the algorithm will tread edges from <code>i</code> to <code>j</code> and from <code>j</code> to <code>i</code> the same.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>connection</code> <p>['weak'|'strong']. For directed graphs, the type of connection to use. Nodes <code>i</code> and <code>j</code> are strongly connected if a path exists both from <code>i</code> to <code>j</code> and from <code>j</code> to <code>i</code>. A directed graph is weakly connected if replacing all of its directed edges with undirected edges produces a connected (undirected) graph. If directed == False, this keyword is not referenced.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'weak'</code> </p> RETURNS DESCRIPTION <code>Series</code> <p>A series of the same length as the number of nodes, where each element corresponds to the connected component of the node at that index.</p>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.connected_components","title":"<code>connected_components(directed=True, connection='weak')</code>","text":"<p>Iterate over the connected components of the network.</p> PARAMETER  DESCRIPTION <code>directed</code> <p>If True (default), then operate on a directed graph: only move from point <code>i</code> to point <code>j</code> along edges from <code>i</code> to <code>j</code>. If False, then compute components on an undirected graph: the algorithm will tread edges from <code>i</code> to <code>j</code> and from <code>j</code> to <code>i</code> the same.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>connection</code> <p>['weak'|'strong']. For directed graphs, the type of connection to use. Nodes <code>i</code> and <code>j</code> are strongly connected if a path exists both from <code>i</code> to <code>j</code> and from <code>j</code> to <code>i</code>. A directed graph is weakly connected if replacing all of its directed edges with undirected edges produces a connected (undirected) graph. If directed == False, this keyword is not referenced.</p> <p> TYPE: <code>ConnectionType</code> DEFAULT: <code>'weak'</code> </p> YIELDS DESCRIPTION <code>NetworkFrame</code> <p>A new NetworkFrame for each connected component.</p>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.from_dict","title":"<code>from_dict(d, orient='columns', index_dtype=int)</code>  <code>classmethod</code>","text":"<p>Return a NetworkFrame from a dictionary representation.</p> <p>The dictionary representation should have keys \"nodes\", \"edges\", and \"directed\". The values of \"nodes\" and \"edges\" should be dictionaries with the same format as the output of pandas.DataFrame.to_dict according to <code>orient</code>.</p> PARAMETER  DESCRIPTION <code>d</code> <p>The dictionary representation of the NetworkFrame.</p> <p> TYPE: <code>dict</code> </p> <code>orient</code> <p>The format of the dictionary according to pandas.DataFrame.to_dict.</p> <p> DEFAULT: <code>'columns'</code> </p> <code>index_dtype</code> <p>The data type of the index of the nodes DataFrame.</p> <p> DEFAULT: <code>int</code> </p> RETURNS DESCRIPTION <code>NetworkFrame</code> <p>A NetworkFrame.</p>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.groupby_nodes","title":"<code>groupby_nodes(by, axis='both', induced=False, **kwargs)</code>","text":"<p>Group the frame by node data for the source or target (or both).</p> <p>See pandas.DataFrame.groupby for more information.</p> PARAMETER  DESCRIPTION <code>by</code> <p>Column name or list of column names to group by.</p> <p> TYPE: <code>Union[Any, list]</code> </p> <code>axis</code> <p>Whether to group by the source nodes (<code>source</code> or <code>0</code>), target nodes (<code>target</code> or <code>0</code>), or both (<code>both</code>).</p> <p> TYPE: <code>EdgeAxisType</code> DEFAULT: <code>'both'</code> </p> <code>induced</code> <p>Whether to only yield groups over induced subgraphs, as opposed to all subgraphs.</p> <p> DEFAULT: <code>False</code> </p> <code>kwargs</code> <p>Additional keyword arguments to pass to pandas.DataFrame.groupby.</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>NodeGroupBy</code> <p>A <code>NodeGroupBy</code> object representing the specified groups.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from networkframe import NetworkFrame\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; nodes = pd.DataFrame(\n...     {\n...         \"name\": [\"A\", \"B\", \"C\", \"D\", \"E\"],\n...         \"color\": [\"red\", \"blue\", \"blue\", \"red\", \"blue\"],\n...     },\n...     index=[0, 1, 2, 3, 4],\n... )\n&gt;&gt;&gt; edges = pd.DataFrame(\n...     {\n...         \"source\": [0, 1, 2, 3, 4],\n...         \"target\": [1, 2, 3, 4, 0],\n...         \"weight\": [1, 2, 3, 4, 5],\n...     }\n... )\n&gt;&gt;&gt; nf = NetworkFrame(nodes, edges)\n&gt;&gt;&gt; for color, subgraph in nf.groupby_nodes(\"color\", axis=\"both\"):\n...     print(color)\n...     print(subgraph.edges)\n('blue', 'blue')\n    source  target  weight\n1       1       2       2\n3       2       1       4\n('blue', 'red')\n    source  target  weight\n2       2       3       3\n('red', 'blue')\n    source  target  weight\n0       0       1       1\n('red', 'red')\n    source  target  weight\n4       3       0       5\n</code></pre>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.is_fully_connected","title":"<code>is_fully_connected(directed=True, connection='weak')</code>","text":"<p>Return whether the network is fully connected.</p> PARAMETER  DESCRIPTION <code>directed</code> <p>If True (default), then operate on a directed graph: only move from point <code>i</code> to point <code>j</code> along edges from <code>i</code> to <code>j</code>. If False, then compute components on an undirected graph: the algorithm will tread edges from <code>i</code> to <code>j</code> and from <code>j</code> to <code>i</code> the same.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>connection</code> <p>['weak'|'strong']. For directed graphs, the type of connection to use. Nodes <code>i</code> and <code>j</code> are strongly connected if a path exists both from <code>i</code> to <code>j</code> and from <code>j</code> to <code>i</code>. A directed graph is weakly connected if replacing all of its directed edges with undirected edges produces a connected (undirected) graph. If directed == False, this keyword is not referenced.</p> <p> TYPE: <code>ConnectionType</code> DEFAULT: <code>'weak'</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the network is fully connected.</p>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.k_hop_neighborhood","title":"<code>k_hop_neighborhood(node_id, k, directed=False)</code>","text":"<p>Return the k-hop neighborhood of a node.</p> PARAMETER  DESCRIPTION <code>node_id</code> <p>The node ID to use to select the k-hop neighborhood.</p> <p> TYPE: <code>Union[int, str]</code> </p> <code>k</code> <p>The number of hops to consider.</p> <p> TYPE: <code>int</code> </p> <code>directed</code> <p>Whether to consider the network as directed for computing the reachable nodes.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <p>A new NetworkFrame with only the k-hop neighborhood of the given node.</p>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.label_nodes_by_component","title":"<code>label_nodes_by_component(name='component', inplace=False, directed=True, connection='weak')</code>","text":"<p>Add a column to <code>.nodes</code> labeling which connected component they are in.</p> PARAMETER  DESCRIPTION <code>directed</code> <p>If True (default), then operate on a directed graph: only move from point <code>i</code> to point <code>j</code> along edges from <code>i</code> to <code>j</code>. If False, then compute components on an undirected graph: the algorithm will tread edges from <code>i</code> to <code>j</code> and from <code>j</code> to <code>i</code> the same.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>connection</code> <p>['weak'|'strong']. For directed graphs, the type of connection to use. Nodes <code>i</code> and <code>j</code> are strongly connected if a path exists both from <code>i</code> to <code>j</code> and from <code>j</code> to <code>i</code>. A directed graph is weakly connected if replacing all of its directed edges with undirected edges produces a connected (undirected) graph. If directed == False, this keyword is not referenced.</p> <p> TYPE: <code>ConnectionType</code> DEFAULT: <code>'weak'</code> </p> <code>name</code> <p>The name of the column to add to <code>.nodes</code>.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'component'</code> </p> <code>inplace</code> <p>Whether to modify the <code>NetworkFrame</code> rather than returning a new one. Copies the nodes dataframe if <code>inplace=False</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Optional[Self]</code> <p>A new NetworkFrame with the component labels added to <code>.nodes</code>. If <code>inplace=True</code>, returns <code>None</code>.</p>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.largest_connected_component","title":"<code>largest_connected_component(directed=True, connection='weak', inplace=False, verbose=False)</code>","text":"<p>Find the largest connected component of the network.</p> PARAMETER  DESCRIPTION <code>directed</code> <p>If True (default), then operate on a directed graph: only move from point <code>i</code> to point <code>j</code> along edges from <code>i</code> to <code>j</code>. If False, then compute components on an undirected graph: the algorithm will tread edges from <code>i</code> to <code>j</code> and from <code>j</code> to <code>i</code> the same.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>connection</code> <p>['weak'|'strong']. For directed graphs, the type of connection to use. Nodes <code>i</code> and <code>j</code> are strongly connected if a path exists both from <code>i</code> to <code>j</code> and from <code>j</code> to <code>i</code>. A directed graph is weakly connected if replacing all of its directed edges with undirected edges produces a connected (undirected) graph. If directed == False, this keyword is not referenced.</p> <p> TYPE: <code>ConnectionType</code> DEFAULT: <code>'weak'</code> </p> <code>inplace</code> <p>Whether to modify the <code>NetworkFrame</code> to select only the largest connected component, rather than returning a new one.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>verbose</code> <p>Whether to print the number of nodes removed when taking the largest connected component.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Optional[Self]</code> <p>A new NetworkFrame with only the largest connected component. If <code>inplace=True</code>, returns <code>None</code>.</p>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.n_connected_components","title":"<code>n_connected_components(directed=True, connection='weak')</code>","text":"<p>Return the number of connected components of the network.</p> PARAMETER  DESCRIPTION <code>directed</code> <p>If True (default), then operate on a directed graph: only move from point <code>i</code> to point <code>j</code> along edges from <code>i</code> to <code>j</code>. If False, then compute components on an undirected graph: the algorithm will tread edges from <code>i</code> to <code>j</code> and from <code>j</code> to <code>i</code> the same.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>connection</code> <p>['weak'|'strong']. For directed graphs, the type of connection to use. Nodes <code>i</code> and <code>j</code> are strongly connected if a path exists both from <code>i</code> to <code>j</code> and from <code>j</code> to <code>i</code>. A directed graph is weakly connected if replacing all of its directed edges with undirected edges produces a connected (undirected) graph. If directed == False, this keyword is not referenced.</p> <p> TYPE: <code>ConnectionType</code> DEFAULT: <code>'weak'</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The number of connected components.</p>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.node_agreement","title":"<code>node_agreement(other)</code>","text":"<p>Return the fraction of nodes in self that are also in other.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other NetworkFrame to compare to.</p> <p> TYPE: <code>Self</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The fraction of nodes that are shared between the two NetworkFrames.</p>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.query_edges","title":"<code>query_edges(expr, inplace=False, local_dict=None, global_dict=None, **kwargs)</code>","text":"<p>Select a subnetwork via a query the <code>.edges</code> DataFrame.</p> PARAMETER  DESCRIPTION <code>expr</code> <p>The query to use on <code>.edges</code>. See pandas.DataFrame.query for more information.</p> <p> TYPE: <code>str</code> </p> <code>inplace</code> <p>Whether to modify the <code>NetworkFrame</code> rather than returning a new one.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>local_dict</code> <p>A dictionary of local variables. Useful for using the <code>@</code> expressions in pandas.DataFrame.query. It may be useful to pass <code>local_dict=locals()</code> to accomplish this.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>global_dict</code> <p>A dictionary of global variables. Useful for using the <code>@</code> expressions in pandas.DataFrame.query. It may be useful to pass <code>global_dict=globals()</code> to accomplish this.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional keyword arguments to pass to pandas.DataFrame.query.</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Optional[Self]</code> <p>A new NetworkFrame for the subnetwork. If <code>inplace=True</code>, returns <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from networkframe import NetworkFrame\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; nodes = pd.DataFrame(\n...     {\n...         \"name\": [\"A\", \"B\", \"C\", \"D\", \"E\"],\n...         \"color\": [\"red\", \"blue\", \"blue\", \"red\", \"blue\"],\n...     },\n...     index=[0, 1, 2, 3, 4],\n... )\n&gt;&gt;&gt; edges = pd.DataFrame(\n...     {\n...         \"source\": [0, 1, 2, 3, 4],\n...         \"target\": [1, 2, 3, 4, 0],\n...         \"weight\": [1, 2, 3, 4, 5],\n...     }\n... )\n&gt;&gt;&gt; nf = NetworkFrame(nodes, edges)\n&gt;&gt;&gt; sub_nf = nf.query_edges(\"weight &gt; 2\") # select subnetwork of edges with weight &gt; 2\n&gt;&gt;&gt; sub_nf\nNetworkFrame(nodes=(5, 2), edges=(3, 3))\n</code></pre>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.query_nodes","title":"<code>query_nodes(expr, inplace=False, local_dict=None, global_dict=None, **kwargs)</code>","text":"<p>Select a subnetwork via a query the <code>.nodes</code> DataFrame.</p> PARAMETER  DESCRIPTION <code>expr</code> <p>The query to use on <code>.nodes</code>. See pandas.DataFrame.query for more information.</p> <p> TYPE: <code>str</code> </p> <code>inplace</code> <p>Whether to modify the <code>NetworkFrame</code> rather than returning a new one.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>local_dict</code> <p>A dictionary of local variables. Useful for using the <code>@</code> expressions in pandas.DataFrame.query. It may be useful to pass <code>local_dict=locals()</code> to accomplish this.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>global_dict</code> <p>A dictionary of global variables. Useful for using the <code>@</code> expressions in pandas.DataFrame.query. It may be useful to pass <code>global_dict=globals()</code> to accomplish this.</p> <p> TYPE: <code>Optional[dict]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional keyword arguments to pass to pandas.DataFrame.query.</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Optional[Self]</code> <p>A new NetworkFrame for the subnetwork. If <code>inplace=True</code>, returns <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from networkframe import NetworkFrame\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; nodes = pd.DataFrame(\n...     {\n...         \"name\": [\"A\", \"B\", \"C\", \"D\", \"E\"],\n...         \"color\": [\"red\", \"blue\", \"blue\", \"red\", \"blue\"],\n...     },\n...     index=[0, 1, 2, 3, 4],\n... )\n&gt;&gt;&gt; edges = pd.DataFrame(\n...     {\n...         \"source\": [0, 1, 2, 3, 4],\n...         \"target\": [1, 2, 3, 4, 0],\n...         \"weight\": [1, 2, 3, 4, 5],\n...     }\n... )\n&gt;&gt;&gt; nf = NetworkFrame(nodes, edges)\n&gt;&gt;&gt; sub_nf = nf.query_nodes(\"color == 'red'\") # select subnetwork of red nodes\n&gt;&gt;&gt; sub_nf\nNetworkFrame(nodes=(2, 2), edges=(2, 3))\n</code></pre>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.reindex_nodes","title":"<code>reindex_nodes(index)</code>","text":"<p>Reindex <code>.nodes</code>, also removes edges as necessary.</p> <p>See pandas.DataFrame.reindex for more information on reindexing.</p> PARAMETER  DESCRIPTION <code>index</code> <p>The new index to use.</p> <p> TYPE: <code>Index</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>A new NetworkFrame with the reindexed nodes.</p>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.remove_nodes","title":"<code>remove_nodes(nodes, inplace=False)</code>","text":"<p>Remove nodes from the network and remove edges that are no longer valid.</p> PARAMETER  DESCRIPTION <code>nodes</code> <p>The index of nodes to remove. If a <code>pd.DataFrame</code> is passed, its index is used; otherwise the object is interpreted as an index-like.</p> <p> TYPE: <code>Union[DataFrame, Index]</code> </p> RETURNS DESCRIPTION <code>Optional[Self]</code> <p>A new NetworkFrame with the nodes removed. If <code>inplace=True</code>, returns <code>None</code>.</p>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.remove_unused_nodes","title":"<code>remove_unused_nodes(inplace=False)</code>","text":"<p>Remove nodes that are not connected to any edges.</p> PARAMETER  DESCRIPTION <code>inplace</code> <p>Whether to modify the <code>NetworkFrame</code> rather than returning a new one.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Optional[Self]</code> <p>A new NetworkFrame with the unused nodes removed. If <code>inplace=True</code>, returns <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from networkframe import NetworkFrame\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; nodes = pd.DataFrame(\n...     {\n...         \"name\": [\"A\", \"B\", \"C\", \"D\", \"E\"],\n...         \"color\": [\"red\", \"blue\", \"blue\", \"red\", \"blue\"],\n...     },\n...     index=[0, 1, 2, 3, 4],\n... )\n&gt;&gt;&gt; edges = pd.DataFrame(\n...     {\n...         \"source\": [0, 1, 2, 2, 3],\n...         \"target\": [1, 2, 3, 1, 0],\n...         \"weight\": [1, 2, 3, 4, 5],\n...     }\n... )\n&gt;&gt;&gt; nf = NetworkFrame(nodes, edges)\n&gt;&gt;&gt; sub_nf = nf.remove_unused_nodes()\n&gt;&gt;&gt; sub_nf\nNetworkFrame(nodes=(4, 2), edges=(5, 3))\n</code></pre>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.select_component_from_node","title":"<code>select_component_from_node(node_id, directed=True, inplace=False)</code>","text":"<p>Select the connected component containing the given node.</p> <p>This function avoids computing the entire connected component structure of the graph, instead using a shortest path algorithm to find the connected component of the node of interest. As such, it may be faster than using <code>connected_components</code>.</p> PARAMETER  DESCRIPTION <code>node_id</code> <p>The node ID to use to select the connected component.</p> <p> TYPE: <code>Any</code> </p> <code>directed</code> <p>Whether to consider the network as directed for computing the reachable nodes.</p> <p> DEFAULT: <code>True</code> </p> <code>inplace</code> <p>Whether to modify the <code>NetworkFrame</code> rather than returning a new one.</p> <p> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Optional[Self]</code> <p>A new NetworkFrame with only the connected component containing the given node. If <code>inplace=True</code>, returns <code>None</code>.</p>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.to_adjacency","title":"<code>to_adjacency(weight_col='weight', aggfunc='sum')</code>","text":"<p>Return the adjacency matrix of the network as a pandas.DataFrame.</p> <p>Source nodes are the rows and target nodes are the columns. The adjacency matrix will be returned in the same order as the nodes in <code>.nodes</code>.</p> PARAMETER  DESCRIPTION <code>weight_col</code> <p>The column in <code>.edges</code> to use as the weight for the adjacency matrix. In the current implementation this must be set; future releases will support <code>None</code> to deal with unweighted networks.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'weight'</code> </p> <code>aggfunc</code> <p>The function to use to aggregate multiple edges between the same source and target nodes. See pandas.DataFrame.pivot_table for more information.</p> <p> TYPE: <code>Union[str, Callable]</code> DEFAULT: <code>'sum'</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>The adjacency matrix of the network as a pd.DataFrame.</p>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.to_dict","title":"<code>to_dict(orient='dict')</code>","text":"<p>Return a dictionary representation of the NetworkFrame.</p> PARAMETER  DESCRIPTION <code>orient</code> <p>The format of the dictionary according to pandas.DataFrame.to_dict.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'dict'</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary representation of the NetworkFrame.</p>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.to_json","title":"<code>to_json(orient='dict')</code>","text":"<p>Return a JSON (string) representation of the NetworkFrame.</p> PARAMETER  DESCRIPTION <code>orient</code> <p>The format of the dictionary according to pandas.DataFrame.to_dict.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'dict'</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A JSON (string) representation of the NetworkFrame.</p>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.to_networkx","title":"<code>to_networkx(create_using=None)</code>","text":"<p>Return a NetworkX graph representation of the network.</p> <p>This NetworkX graph also includes all node and edge attributes.</p> PARAMETER  DESCRIPTION <code>create_using</code> <p>The NetworkX graph class to use to create the graph. If <code>None</code>, defaults to <code>nx.MultiDiGraph</code> if the network is directed and <code>nx.MultiGraph</code> if the network is undirected.</p> <p> TYPE: <code>Optional[Union[Graph, DiGraph, MultiDiGraph, MultiGraph]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Union[Graph, DiGraph, MultiDiGraph, MultiGraph]</code> <p>A NetworkX representation of the network.</p>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.to_sparse_adjacency","title":"<code>to_sparse_adjacency(weight_col=None, aggfunc='sum', verify_integrity=True)</code>","text":"<p>Return the adjacency matrix of the network as a scipy.sparse.csr_array.</p> <p>Source nodes are the rows and target nodes are the columns. The adjacency matrix will be returned in the same order as the nodes in <code>.nodes</code>.</p> PARAMETER  DESCRIPTION <code>weight_col</code> <p>The column in <code>.edges</code> to use as the weight for the adjacency matrix. If <code>None</code>, then the number of edges between the source and target nodes will be used.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>aggfunc</code> <p>The function to use to aggregate multiple edges between the same source and target nodes. See pandas.DataFrame.pivot_table for more information.</p> <p> DEFAULT: <code>'sum'</code> </p> <code>verify_integrity</code> <p>Whether to verify that all source and target nodes are in the nodes index. Adds some overhead but prevents a difficult to decipher error later on if the node table is missing entries.</p> <p> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>csr_array</code> <p>The adjacency matrix of the network as a scipy.sparse.csr_array.</p>"},{"location":"reference/networkframe/#networkframe.NetworkFrame.to_sparse_adjacency--notes","title":"Notes","text":"<p>This method currently only supports scipy.sparse.csr_array output, but in the future may support other sparse array formats.</p>"},{"location":"reference/networkframe/#networkframe.LocIndexer","title":"<code>networkframe.LocIndexer(frame)</code>","text":"<p>A class for indexing a NetworkFrame using .loc.</p> <p>Indexer for NetworkFrame.</p>"},{"location":"reference/networkframe/#networkframe.LocIndexer.__getitem__","title":"<code>__getitem__(args)</code>","text":"<p>Return a NetworkFrame with the given labels.</p>"},{"location":"reference/nodegroupby/","title":"NodeGroupBy","text":""},{"location":"reference/nodegroupby/#networkframe.NodeGroupBy","title":"<code>networkframe.NodeGroupBy(frame, source_groupby, target_groupby, induced=False)</code>","text":"<p>A class for grouping a <code>NetworkFrame</code> by a set of labels.</p> <p>Groupby on nodes.</p> PARAMETER  DESCRIPTION <code>frame</code> <p>description</p> <p> </p> <code>source_groupby</code> <p>description</p> <p> </p> <code>target_groupby</code> <p>description</p> <p> </p> <code>induced</code> <p>description</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"reference/nodegroupby/#networkframe.NodeGroupBy.has_source_groups","title":"<code>has_source_groups</code>  <code>property</code>","text":"<p>Whether the frame has row groups.</p>"},{"location":"reference/nodegroupby/#networkframe.NodeGroupBy.has_target_groups","title":"<code>has_target_groups</code>  <code>property</code>","text":"<p>Whether the frame has column groups.</p>"},{"location":"reference/nodegroupby/#networkframe.NodeGroupBy.source_groups","title":"<code>source_groups</code>  <code>property</code>","text":"<p>Return the row groups.</p>"},{"location":"reference/nodegroupby/#networkframe.NodeGroupBy.target_groups","title":"<code>target_groups</code>  <code>property</code>","text":"<p>Return the column groups.</p>"},{"location":"reference/nodegroupby/#networkframe.NodeGroupBy.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over the groups.</p>"},{"location":"reference/nodegroupby/#networkframe.NodeGroupBy.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of groups.</p>"},{"location":"reference/reference/","title":"Reference","text":"<p>Documentation for the top-level package of <code>networkframe</code>, which mainly consists of the <code>NetworkFrame</code> class.</p>"}]}